<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>The Kecc compiler. (In progress.) | Mountagha’s Blog</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="The Kecc compiler. (In progress.)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A corner of the web where I will share my passions with you." />
<meta property="og:description" content="A corner of the web where I will share my passions with you." />
<link rel="canonical" href="/kecc-compiler.html" />
<meta property="og:url" content="/kecc-compiler.html" />
<meta property="og:site_name" content="Mountagha’s Blog" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="The Kecc compiler. (In progress.)" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"A corner of the web where I will share my passions with you.","headline":"The Kecc compiler. (In progress.)","url":"/kecc-compiler.html"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style" type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/assets/css/style.css?v=341f57efe513ae7b36eabd222593affc80f1652b">
    <nav>
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="/about/">About</a></li>
  </ul>
</nav>

<style>
nav ul {
  list-style-type: none;
  padding: 0;
  display: flex;
  gap: 10px;
  justify-content: right;
}

nav ul li {
  display: inline;
}

nav ul li a {
  text-decoration: none;
  padding: 10px;
  background-color: #4CAF50;
  color: white;
  border-radius: 5px;
}

nav ul li a:hover {
  background-color: #45a049;
}
</style>


  </head>
  <body>
    <a id="skip-to-content" href="#content">Skip to the content.</a>

    <header class="page-header" role="banner">
      <h1 class="project-name">The Kecc compiler. (In progress.)</h1>
      <h2 class="project-tagline">A corner of the web where I will share my passions with you.</h2>
      
        <a href="https://github.com/Mountagha" target="_blank" class="btn">GitHub</a>
        <a href="https://www.linkedin.com/in/mamadou-mountagha-bah-b40701141/" target="_blank" class="btn">LinkedIn</a>
      
      
    </header>

    <main id="content" class="main-content" role="main">
      <h2 id="the-kecc-compiler-in-progress">The Kecc compiler. (In progress.)</h2>
<p>This is my second post on compilers. 
KECC is C compiler developped at <a href="https://www.kaist.ac.kr/en/">KAIST</a> lab using the Rust programming language. There are few reasons that made me got into another compiler project</p>
<ul>
  <li>I recently learned Rust and wanted to used it in a real life project for more understanding.</li>
  <li>Unlike <a href="/cool-compiler.html">COOL compiler</a> which is developped in a monolithic way, KECC adopts the very recent compiler development technics which made it very modular and closed to what is used in real compilers structures like <a href="https://llvm.org/">LLVM</a>.</li>
  <li>This is my occasion to implement real life optimizations used in real life compilers</li>
  <li>the KECC compiler is provided with a fair amount skeleton code which is most like 
contributing to a open Source project. For somebody aspiring to have a fair
amount of contribution to big open source projects like <a href="https://github.com/pytorch/pytorch">Pytorch</a> and <a href="LLVM">link</a>,
this is a perfect way to my maiden voyage into open source contribution.</li>
</ul>

<h3 id="kecc-organization">KECC organization:</h3>
<p>Unlike the <a href="/cool-compiler.html">Cool Compiler</a> KECC emphasizes more on the backend part or would I say emphasizes less on the front part 
of the compiler (lexer parser) which are handled by an external crate lang_c which parses the C
language into an AST. The main part of the project consists of translating the 
provided AST into an <a href="https://en.wikipedia.org/wiki/Static_single-assignment_form">SSA-based intermediate representation (IR)</a> 
then applied some optimizations upon the generated IR (Gloval Value Numbering, constant propagation mem2reg…) 
and finish by emitting a <a href="https://fr.wikipedia.org/wiki/RISC-V">RISC-V</a> assembly program.</p>

<h3 id="parser">parser</h3>
<p>KAIST parser is entirely handled by <a href="https://crates.io/crates/lang-c">Rust Lang_c crate</a> which parses the source code into an AST whose root is the Translation unit. The root got external declarations as children which also got their children (You know the music).</p>

<pre><code class="language-Rust">
// From 6.9 External definitions

/// Entire C source file after preprocessing
///
/// (C11 6.9)
#[derive(Debug, PartialEq, Clone)]
pub struct TranslationUnit(pub Vec&lt;Node&lt;ExternalDeclaration&gt;&gt;);

/// Top-level elements of a C program
///
/// (C11 6.9)
#[derive(Debug, PartialEq, Clone)]
pub enum ExternalDeclaration {
    Declaration(Node&lt;Declaration&gt;),
    StaticAssert(Node&lt;StaticAssert&gt;),
    FunctionDefinition(Node&lt;FunctionDefinition&gt;),
}

/// Function definition
///
/// (C11 6.9.1)
#[derive(Debug, PartialEq, Clone)]
pub struct FunctionDefinition {
    /// Return type of the function, possibly mixed with other specifiers
    pub specifiers: Vec&lt;Node&lt;DeclarationSpecifier&gt;&gt;,
    /// Contains function name and parameter list
    pub declarator: Node&lt;Declarator&gt;,
    /// K&amp;R style parameter type definitions (C11 6.9.1 §6)
    pub declarations: Vec&lt;Node&lt;Declaration&gt;&gt;,
    /// Body of the function.
    pub statement: Node&lt;Statement&gt;,
}

</code></pre>
<p>In that part of the project, an AST printer was asked to be implemented, going through the AST and then regerenating the C code. The way the parser is tested is pretty clever. The AST printer goes through the AST parser and then generate back the original C source code. To test it, the generated code was parsed again, and the resulting AST was compared with the original to ensure they were identical.</p>

<pre><code class="language-Rust">
impl WriteLine for TranslationUnit {
    fn write_line(&amp;self, indent: usize, write: &amp;mut dyn Write) -&gt; Result&lt;()&gt; {
        for ext_decl in &amp;self.0 {
            ext_decl.write_line(indent, write)?;
            writeln!(write)?;
        }
        Ok(())
    }
}

impl WriteLine for ExternalDeclaration {
    fn write_line(&amp;self, indent: usize, write: &amp;mut dyn Write) -&gt; Result&lt;()&gt; {
        match self {
            Self::Declaration(decl) =&gt; decl.write_line(indent, write),
            Self::StaticAssert(_) =&gt; panic!(),
            Self::FunctionDefinition(fdef) =&gt; fdef.write_line(indent, write),
        }
    }
}

</code></pre>

<h3 id="ir-generation">IR generation</h3>
<p>The intermediate representation (IR) generation process has been particularly challenging, as it was my first time working on such a task. What made it even more difficult was the absence of a formal specification for the IR. Instead, I had to rely on a collection of C source files paired with their corresponding IR outputs. It felt somewhat like a reverse engineering exercise to deduce and produce the correct IR.</p>

<p>Like most modern IRs, KECC IR is based on SSA (Static Single Assignment) form. In this representation, each register is assigned a value only once, which simplifies the analysis and facilitates optimizations, as we will explore later.</p>

<p>Below is an example of a Fibonacci program written in C alongside its corresponding generated IR.</p>

<pre><code class="language-C">
int nonce = 1; // For random input

int fibonacci(int n) {
    if (n &lt; 2) {
        return n;
    }

    return fibonacci(n - 2) + fibonacci(n - 1);
}

int main() {
    int number = nonce % 20;
    return fibonacci(number);
}

</code></pre>
<p>the generated IR.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var i32 @nonce = 1

fun i32 @fibonacci (i32) {
init:
  bid: b0
  allocations: 
    %l0:i32:n

block b0:
  %b0:p0:i32:n
  %b0:i0:unit = store %b0:p0:i32 %l0:i32*
  %b0:i1:i32 = load %l0:i32*
  %b0:i2:u1 = cmp lt %b0:i1:i32 2:i32
  br %b0:i2:u1, b1(), b2()

block b1:
  %b1:i0:i32 = load %l0:i32*
  ret %b1:i0:i32

block b2:
  j b3()

block b3:
  %b3:i0:i32 = load %l0:i32*
  %b3:i1:i32 = sub %b3:i0:i32 2:i32
  %b3:i2:i32 = call @fibonacci:[ret:i32 params:(i32)]*(%b3:i1:i32)
  %b3:i3:i32 = load %l0:i32*
  %b3:i4:i32 = sub %b3:i3:i32 1:i32
  %b3:i5:i32 = call @fibonacci:[ret:i32 params:(i32)]*(%b3:i4:i32)
  %b3:i6:i32 = add %b3:i2:i32 %b3:i5:i32
  ret %b3:i6:i32

block b4:
  j b3()

block b5:
  ret undef:i32
}

fun i32 @main () {
init:
  bid: b0
  allocations: 
    %l0:i32:number

block b0:
  %b0:i0:i32 = load @nonce:i32*
  %b0:i1:i32 = mod %b0:i0:i32 20:i32
  %b0:i2:unit = store %b0:i1:i32 %l0:i32*
  %b0:i3:i32 = load %l0:i32*
  %b0:i4:i32 = call @fibonacci:[ret:i32 params:(i32)]*(%b0:i3:i32)
  ret %b0:i4:i32

block b1:
  ret 0:i32
}

</code></pre></div></div>
<h4 id="test-driven-development-tdd-to-produce-the-correct-ir">Test Driven Development (TDD) to produce the correct IR.</h4>

<p>KECC provides an excellent skeleton code, including an IR interpreter that evaluates the generated IR and produces a result equivalent to executing the original C code. This interpreter made testing the IR generation process straightforward: by interpreting both the provided IR and the IR generated by our program, we could compare their results to validate correctness.</p>

<p>One particularly interesting aspect was how the author suggested developing the IR generation process. KECC comes with a fuzzer, a tool that generates random C files—ranging from simple programs with a few lines to highly complex ones with thousands of lines. The fuzzer tests the IR generation pipeline by feeding these random C files into our IR generation code, interpreting the resulting IR through the KECC IR interpreter, and comparing the output to that produced by GCC or Clang.</p>

<p>This process proved invaluable for uncovering numerous bugs that would have been almost impossible to detect otherwise. The workflow was as follows:</p>

<ol>
  <li>Generate a random C file using the fuzzer.</li>
  <li>Generate the corresponding IR for the C file using our IR generation program.</li>
  <li>Interpret the generated IR using KECC’s IR interpreter.</li>
  <li>Compile and execute the original C file with GCC or Clang.</li>
  <li>Compare the results of both executions.</li>
</ol>

<h3 id="optimization">Optimization</h3>

<h4 id="cfg-simplification">CFG simplification</h4>
<h4 id="constant-propagation">constant propagation</h4>
<h4 id="deadcode-elimination">Deadcode Elimination</h4>
<h4 id="memory-to-register-mem2reg">Memory to Register (mem2reg)</h4>

<h3 id="code-generation-riscv-64">Code Generation (RISCV 64)</h3>

<h2 id="conclusion">Conclusion</h2>

<p><a href="./">back</a></p>


      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="https://github.com/Mountagha">Mountagha.github.io</a> is maintained by <a href="https://github.com/Mountagha">Mountagha</a>.</span>
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </main>
  </body>
</html>